package org.teleight.teleightbots.codegen.generator.generators;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.WildcardTypeName;
import org.jetbrains.annotations.NotNull;
import org.teleight.teleightbots.codegen.json.TelegramField;
import org.teleight.teleightbots.codegen.json.TelegramMethod;

import javax.lang.model.element.Modifier;
import java.io.Serializable;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public non-sealed class MethodGenerator implements Generator<TelegramMethod> {

    @Override
    public TypeSpec.Builder generate(String key, TelegramMethod method) {
        // Methods are in camelCase. We need to make the first letter capitalized
        String correctedClassName = key.substring(0, 1).toUpperCase() + key.substring(1);

        TypeSpec.Builder typeSpecBuilder = TypeSpec.recordBuilder(correctedClassName)
                .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
                        .addMember("value", "$S", "unused")
                        .build())
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc("AutoGenerated Code. Do not modify!\n");

        // check if method had any subtypes
        if (!(method.subtypeOf() == null)) {
            for (TypeName subtypeOf : method.subtypeOf()) {
                typeSpecBuilder.addSuperinterface(subtypeOf);
            }
        }

        // Start populating the fields of the record
        Map<TelegramField, Boolean> populatedFields = populateFields(method.fields(), typeSpecBuilder);

        // Override the getEndpointURL method
        typeSpecBuilder.addMethod(MethodSpec.methodBuilder("getEndpointURL")
                .addAnnotation(Override.class)
                .addAnnotation(NotNull.class)
                .addModifiers(Modifier.PUBLIC)
                .addStatement("return $S", key)
                .returns(String.class)
                .build());

        // A telegram method can return different types.
        //  - If the method returns only one type, then the super interface is ApiMethod<T>
        //  - If the method returns multiple types, we need to extend to ApiMethodSerializable<T>
        //  - If the method returns one type but needs a multipart field, we need to extend to MultiPartApiMethod<T>
        if (containsMultipart(method)) {
            generateMultipartMethod(method.returns()[0], typeSpecBuilder, populatedFields);
        } else if (method.returns().length == 1) {
            generateOneReturnMethod(method.returns()[0], typeSpecBuilder);
        } else {
            generateMultipleReturnMethod(method, typeSpecBuilder);
        }

        generateBuilderClass(correctedClassName, populatedFields, typeSpecBuilder);

        return typeSpecBuilder;
    }

    @Override
    public String getPackageName() {
        return METHODS_PACKAGE_NAME;
    }

    private void generateOneReturnMethod(TypeName type, TypeSpec.Builder typeSpecBuilder) {
        ParameterizedTypeName parameterizedTypeName = ParameterizedTypeName.get(API_METHOD_INTERFACE, type);
        typeSpecBuilder.addSuperinterface(parameterizedTypeName);
        addDeserializeResponseMethod(type, typeSpecBuilder);
    }

    private void addDeserializeResponseMethod(TypeName type, TypeSpec.Builder typeSpecBuilder) {
        typeSpecBuilder.addMethod(MethodSpec.methodBuilder("deserializeResponse")
                .addAnnotation(Override.class)
                .addAnnotation(NotNull.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ParameterSpec.builder(String.class, "answer").addAnnotation(NotNull.class).build())
                .addStatement("return deserializeResponse(answer, $T.class)", type)
                .returns(type)
                .build());
    }

    private boolean containsMultipart(TelegramMethod method) {
        if (method.fields() == null) return false;
        for (TelegramField field : method.fields()) {
            assert field != null;
            if (field.description().toLowerCase().contains("multipart")) {
                return true;
            }
        }
        return false;
    }

    private void generateMultipartMethod(TypeName type, TypeSpec.Builder typeSpecBuilder, Map<TelegramField, Boolean> populatedFields) {
        ParameterizedTypeName multipartParameterizedTypeName = ParameterizedTypeName.get(API_MULTIPART_METHOD_INTERFACE, type);
        ParameterizedTypeName mapParameterizedTypeName = ParameterizedTypeName.get(JAVA_MAP_CLASSNAME, JAVA_STRING_CLASSNAME, INPUTFILE);
        ParameterizedTypeName objectParameterizedTypeName = ParameterizedTypeName.get(JAVA_MAP_CLASSNAME, JAVA_STRING_CLASSNAME, OBJECT_CLASSNAME);
        typeSpecBuilder.addSuperinterface(multipartParameterizedTypeName);

        addDeserializeResponseMethod(type, typeSpecBuilder);

        MethodSpec.Builder getParamsMethodBuilder = MethodSpec.methodBuilder("getParams")
                .addAnnotation(Override.class)
                .addAnnotation(NotNull.class)
                .addModifiers(Modifier.PUBLIC)
                .addStatement("$T<String, Object> params = new $T<>()", Map.class, HashMap.class)
                .returns(objectParameterizedTypeName);

        MethodSpec.Builder getFilesMethodBuilder = MethodSpec.methodBuilder("getFiles")
                .addAnnotation(Override.class)
                .addAnnotation(NotNull.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(mapParameterizedTypeName);

        getFilesMethodBuilder.addCode("return $T.of(", Map.class);
        int count = 0;
        for (Map.Entry<TelegramField, Boolean> telegramFieldBooleanEntry : populatedFields.entrySet()) {
            TelegramField telegramField = telegramFieldBooleanEntry.getKey();
            if (telegramField.description().toLowerCase().contains("multipart")) {

                if (telegramField.name().equals("disable_content_type_detection"))
                    continue;

                if (count > 0) {
                    getFilesMethodBuilder.addCode(", ");
                }
                getFilesMethodBuilder.addCode("$S, $L", telegramField.name(), toCamelCase(telegramField.name()));
                count++;
            } else {
                getParamsMethodBuilder.beginControlFlow("if ($L != null)", toCamelCase(telegramField.name()));
                getParamsMethodBuilder.addStatement("params.put($S, $L)", telegramField.name(), toCamelCase(telegramField.name()));
                getParamsMethodBuilder.endControlFlow();
            }
        }
        getParamsMethodBuilder.addStatement("return params");
        getFilesMethodBuilder.addCode(");");

        typeSpecBuilder.addMethod(getParamsMethodBuilder.build());
        typeSpecBuilder.addMethod(getFilesMethodBuilder.build());
    }

    private void generateMultipleReturnMethod(TelegramMethod method, TypeSpec.Builder typeSpecBuilder) {
        typeSpecBuilder.addSuperinterface(API_RESULT_SERIALIZABLE_INTERFACE);
        
        TypeName serializableWildcard = WildcardTypeName.subtypeOf(Serializable.class);
        TypeName classParameter = ParameterizedTypeName.get(JAVA_CLASS_CLASSNAME, serializableWildcard);
        TypeName listParameterizedType = ParameterizedTypeName.get(JAVA_LIST_CLASSNAME, classParameter);

        MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder("getSerializableClasses")
                .addAnnotation(Override.class)
                .addAnnotation(NotNull.class)
                .addModifiers(Modifier.PUBLIC)
                .addCode("return $T.of(", List.class)
                .returns(listParameterizedType);

        boolean isLast;
        final TypeName[] returns = method.returns();
        for (int i = 0; i < returns.length; i++) {
            TypeName returnClass = returns[i];
            isLast = i == returns.length - 1;

            methodSpecBuilder.addCode("$T.class", returnClass);
            if (!isLast) {
                methodSpecBuilder.addCode(", ");
            } else {
                methodSpecBuilder.addCode(");");
            }

        }

        typeSpecBuilder.addMethod(methodSpecBuilder.build());
    }

}
