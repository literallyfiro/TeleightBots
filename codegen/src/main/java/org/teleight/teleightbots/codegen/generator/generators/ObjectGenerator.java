package org.teleight.teleightbots.codegen.generator.generators;

import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import org.teleight.teleightbots.codegen.json.TelegramField;
import org.teleight.teleightbots.codegen.json.TelegramObject;

import javax.lang.model.element.Modifier;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public non-sealed class ObjectGenerator implements Generator<TelegramObject> {

    @Override
    public TypeSpec.Builder generate(String name, TelegramObject telegramObject) {
        // If there are subtypes, that means the class must be a sealed class, and must permit its subtypes
        if (telegramObject.subtypes() != null) {
            return generateSealedClass(name, telegramObject);
        }

        // Create default record builder
        TypeSpec.Builder typeSpecBuilder = TypeSpec.recordBuilder(name)
                .addModifiers(Modifier.PUBLIC)
                .addSuperinterface(API_RESULT_INTERFACE)
                .addJavadoc("AutoGenerated Code. Do not modify!");

        // If class is subtype of another class, it must be specified
        if (telegramObject.subtypeOf() != null) {
            for (TypeName subtypeOf : telegramObject.subtypeOf()) {
                typeSpecBuilder.addSuperinterface(subtypeOf);
            }
        }

        // If there are no fields, return the default JavaFile
        if (telegramObject.fields() == null) {
            return typeSpecBuilder;
        }

        // Start adding the fields. Required fields are useful in case the object requires a builder
        List<TelegramField> requiredFields = new ArrayList<>();
        for (TelegramField field : telegramObject.fields()) {
            TypeName type = retrieveMostImportantType(Objects.requireNonNull(field));
            FieldSpec.Builder fieldSpecBuilder = FieldSpec.builder(type, field.name());
            typeSpecBuilder.addField(fieldSpecBuilder.build());
            if (field.required()) {
                requiredFields.add(field);
            }
        }

        // If the telegram object requires a builder, generate it
        if (telegramObject.requiresBuilder()) {
            generateBuilderClass(name, telegramObject.fields(), typeSpecBuilder, requiredFields);
        }

        // All work is done, we can build the JavaFile
        return typeSpecBuilder;
    }

    @Override
    public String getPackageName() {
        return OBJECTS_PACKAGE_NAME;
    }

    private TypeSpec.Builder generateSealedClass(String name, TelegramObject telegramObject) {
        TypeSpec.Builder typeSpecBuilder = TypeSpec.interfaceBuilder(name)
                .addModifiers(Modifier.SEALED, Modifier.PUBLIC)
                .addSuperinterface(API_RESULT_INTERFACE)
                .addJavadoc("AutoGenerated Code. Do not modify!");
        for (TypeName subtype : telegramObject.subtypes()) {
            typeSpecBuilder.addPermits(subtype);
        }
        return typeSpecBuilder;
    }

}
